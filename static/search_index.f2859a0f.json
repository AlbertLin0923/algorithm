[{"id":0,"title":"二叉平衡树","routePath":"/algorithm/guide/binary-tree/balanced-binary-tree","lang":"","toc":[],"domain":"","content":"#\n\n110. 平衡二叉树(简单)\n\nTIP\n\n后序遍历二叉树\n\n在遍历二叉树每个节点前都会遍历其左右子树\n\n比较左右子树的深度，若差值大于1 则返回一个标记 -1表示当前子树不平衡\n\n左右子树有一个不是平衡的，或左右子树差值大于1，则整课树不平衡\n\n若左右子树平衡，返回当前树的深度（左右子树的深度最大值+1）\n\n","frontmatter":{},"version":""},{"id":1,"title":"广度优先","routePath":"/algorithm/guide/binary-tree/bfs","lang":"","toc":[{"text":"参考资料","id":"参考资料","depth":2,"charIndex":42},{"text":"层序遍历","id":"层序遍历","depth":2,"charIndex":149}],"domain":"","content":"#\n\n> 也就是 广度优先算法 bfs Breadth First Search\n\n\n参考资料#\n\nJS 前序遍历、中序遍历、后序遍历、层序遍历详解，深度优先与广度优先区别，附 leetcode 例题题解答案\n\n五三想休息，今天还学习，图解二叉树的层序遍历 BFS（广度优先）模板，附面试题题解\n\n\n层序遍历#\n\n102. 二叉树的层序遍历(中等)\n\n迭代方式解决：\n\n\n\n递归方式解决：\n\n\n\n103. 二叉树的锯齿形层序遍历(中等)\n\n\n\n104. 二叉树的最大深度(简单)\n\n\n\n111. 二叉树的最小深度(简单)\n\n","frontmatter":{},"version":""},{"id":2,"title":"二叉搜索树","routePath":"/algorithm/guide/binary-tree/binary-search-tree","lang":"","toc":[],"domain":"","content":"#\n\n98. 验证二叉搜索树(中等)\n\nTIP\n\n这里需要注意，整颗树左侧都必须小于根节点，右侧也如此；而不仅仅是左节点小于根节点，右节点大于根节点\n\n错误解法：\n\n\n\n","frontmatter":{},"version":""},{"id":3,"title":"深度优先","routePath":"/algorithm/guide/binary-tree/dfs","lang":"","toc":[{"text":"参考资料","id":"参考资料","depth":2,"charIndex":40},{"text":"前序遍历","id":"前序遍历","depth":2,"charIndex":104},{"text":"中序遍历","id":"中序遍历","depth":2,"charIndex":177},{"text":"后序遍历","id":"后序遍历","depth":2,"charIndex":281}],"domain":"","content":"#\n\n> 也就是 深度优先算法 dfs Depth First Search\n\n\n参考资料#\n\nJS 前序遍历、中序遍历、后序遍历、层序遍历详解，深度优先与广度优先区别，附 leetcode 例题题解答案\n\n\n前序遍历#\n\n前序遍历：先访问根，再访问左节点，然后访问左节点的左节点，递归下去，然后才访问右节点\n\n144. 二叉树的前序遍历(简单)\n\n\n\n\n中序遍历#\n\n中序遍历：当跑到到根节点 B 时，先得看看有没有左子树，正好有，所以先遍历了左子树 A 之后才是 B，最后遍历右子树 C，所以完整顺序顺序为 ABC\n\n94. 二叉树的中序遍历(简单)\n\n\n\n\n后序遍历#\n\n后序遍历：从根节点 C 出发，先访问左子树 A，紧接着右子树 B，最后根节点 C，所以顺序为 ABC\n\n145. 二叉树的后序遍历(简单)\n\n","frontmatter":{},"version":""},{"id":4,"title":"介绍","routePath":"/algorithm/guide/introduction","lang":"","toc":[{"text":"第一步，学习常用的数据结构","id":"第一步学习常用的数据结构","depth":2,"charIndex":3},{"text":"第二步，刷题","id":"第二步刷题","depth":2,"charIndex":92},{"text":"","id":"","depth":2,"charIndex":-1}],"domain":"","content":"#\n\n\n第一步，学习常用的数据结构#\n\nHello 算法\n\n《JavaScript数据结构与算法-第三版》\n\n数据结构与算法之美\n\nlabuladong 的算法笔记\n\n吴师兄学算法\n\n\n第二步，刷题#\n\nleetcode\n\n刷题的套路模板\n\n\n#","frontmatter":{},"version":""},{"id":5,"title":"环形链表","routePath":"/algorithm/guide/linked-list/linked-list-cycle","lang":"","toc":[],"domain":"","content":"#\n\nTIP\n\n用哈希表处理即可\n\n141. 环形链表(简单)\n\n\n\n142. 环形链表 II(中等)\n\n","frontmatter":{},"version":""},{"id":6,"title":"链表","routePath":"/algorithm/guide/linked-list/linked-list","lang":"","toc":[],"domain":"","content":"#\n\n83. 删除排序链表中的重复元素(简单)\n\n\n\n206. 反转链表(简单)\n\n迭代方式\n\n\n\n\n头插法\n\n1.定义一个新的头节点 2.依次将节点插入新头节点与第一个节点之间\n\n\n\n19. 删除链表的倒数第 N 个结点(简单)\n\n","frontmatter":{},"version":""},{"id":7,"title":"回文链表","routePath":"/algorithm/guide/linked-list/palindrome-linked-list","lang":"","toc":[],"domain":"","content":"#\n\n234. 回文链表(简单)\n\nTIP\n\n链表只能单向遍历，不连续内存区域，依赖于指针移动来遍历\n\n所以需要拷贝值出来\n\n然后进行数组的双指针判断是否回文\n\n","frontmatter":{},"version":""},{"id":8,"title":"","routePath":"/algorithm/guide/queue","lang":"","toc":[{"text":"队列","id":"队列","depth":2,"charIndex":-1},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":5}],"domain":"","content":"队列#\n\n\n参考资料#\n\n先进先出\n\n","frontmatter":{},"version":""},{"id":9,"title":"","routePath":"/algorithm/guide/stack","lang":"","toc":[{"text":"栈","id":"栈","depth":2,"charIndex":-1},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":4}],"domain":"","content":"栈#\n\n\n参考资料#\n\n先进后出\n\n","frontmatter":{},"version":""}]